# CoroRpc - 基于 C++20 协程的异步 RPC 框架

## ✨ 特性概览

- 🚀 **高性能异步通信** - 基于 C++20 协程和 Boost.Asio 的高性能网络层
- 📡 **跨平台支持** - 支持 Windows、Linux、macOS 等主流操作系统
- 🔄 **多协议序列化** - 支持 JSON 和 Protocol Buffers 两种序列化协议
- 🎯 **智能服务发现** - 基于 etcd 的服务注册与发现机制
- ⚖️ **负载均衡** - 多种负载均衡策略，避免单点故障
- ⏰ **超时重试** - 可配置的超时时间和重试机制
- 🛡️ **异常处理** - 完善的错误处理和异常管理

## 🏗️ 架构设计

CoroRpc 采用分层架构设计，各层职责清晰：

### RPC 数据格式
支持 JSON 和 Protocol Buffers 两种序列化协议，通过统一的序列化接口实现协议无关性。

### 网络层
基于 Boost.Asio 实现，充分利用 C++20 协程特性，提供高性能的异步网络通信能力。支持连接池、异步 IO 操作和高效的事件处理机制。

### 序列化层
采用 LV（Length-Value）格式，通过制定分隔符和添加长度字段，实现高效的序列化和反序列化功能，保证数据的完整性和解析效率。

### 协程层
基于 C++20 协程特性实现，提供原生的异步编程体验，让开发者以同步的方式编写异步代码，大幅提升代码可读性和维护性。

### 服务注册与发现
基于 etcd 分布式键值存储实现服务注册和发现功能：
- **服务注册**：服务提供者启动时向 etcd 注册服务方法和节点信息
- **服务发现**：消费者通过 etcd 查询可用的服务提供者
- **健康检查**：通过 etcd 的 keep-alive 机制维持服务心跳，防止服务失效
- **实时监控**：利用 etcd 的 watch 机制实时感知服务变化

### 负载均衡
在分布式 RPC 框架中，通过将服务拆分为细粒度的方法，结合多种负载均衡策略：
- 轮询策略
- 最少连接数策略  
- 一致性哈希策略
确保请求合理分配到各个服务节点，避免单点故障，提高系统可用性。

### 超时和重试机制
- **超时控制**：支持可配置的调用超时时间，防止资源长时间占用
- **智能重试**：当调用超时或失败时，自动进行重试，支持最大重试次数和重试间隔配置
- **熔断机制**：在连续失败时自动熔断，避免雪崩效应

## 🚀 快速开始

### 环境要求

- C++20 兼容编译器 (GCC 11+, Clang 14+, MSVC 19.30+)
- Boost 1.75+（主要依赖 Asio）
- etcd 客户端库
- Protocol Buffers（可选，用于 ProtoBuf 序列化）

### 安装依赖

各平台安装指南和构建工具配置。

### 基础使用

服务定义、实现、部署和调用的完整流程说明。

## 📚 核心功能

### 序列化协议

#### JSON 序列化
支持自动序列化用户定义类型，提供简洁的声明式接口。

#### Protocol Buffers
完整支持 ProtoBuf 协议，提供类型安全的序列化方案。

### 服务发现

基于 etcd 的完整服务治理方案，包括服务注册、发现、健康检查和动态路由。

### 负载均衡策略

支持多种负载均衡算法，可根据业务场景灵活选择：

- 轮询负载均衡
- 最少连接数负载均衡  
- 一致性哈希负载均衡

### 超时和重试

可配置的超时时间、重试策略和熔断机制，确保系统在异常情况下的稳定性。

## 🛠️ 构建系统

支持主流构建系统和包管理工具，提供简单的集成方案。

## 📊 性能特性

基于协程的轻量级异步模型，提供优异的性能表现：

- 高并发连接处理能力
- 低延迟的 RPC 调用
- 高效的内存使用
- 可扩展的架构设计
